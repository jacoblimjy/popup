const fs = require("fs");
const path = require("path");
const axios = require("axios");
const db = require("../db");
// TODO: we will test with questionService first, but change to pending question service later
const questionService = require("./questionService");
const { validateJSONResponse, validateQuestionStructure, validateRealWords } = require("../utils/llmValidator");

const generateQuestions = async (topic_id, difficulty_id, num_questions) => {
  try {
    // Retrieve topic and difficulty names
    const topic = await getTopicById(topic_id);
    const difficulty = await getDifficultyById(difficulty_id);

    // Get the Jinja2 template prompt
    const prompt = getPromptByTopicAndDifficulty(topic, difficulty);

    // Call OpenAI API to generate questions
    const llmResponse = await callOpenAPI(prompt);

    // Validate the response is in JSON format
    const questions = validateJSONResponse(llmResponse);

    // Validate each question structure
    const validQuestions = [];
    for (const question of questions) {
      if (!validateQuestionStructure(question)) {
        console.error("Invalid question structure:", question);
        continue;
      }

      // Validate correct_answer contains real words
      if (!validateRealWords(question.correct_answer)) {
        console.error("Hallucinated word detected in: ", question.correct_answer);
        continue;
      }

    //   TODO: Custom Logic for different topics
    
      question.topic_id = topic_id;
      question.difficulty_id = difficulty_id;
      question.is_LLM_generated = true;
      validQuestions.push(question);
    }

    if (validQuestions.length === 0) {
      throw new Error("No valid questions generated by LLM");
    }

    // Create pending questions in bulk
    // TODO: Change to pending question service later after testing
    const result = await questionService.createQuestionsBulk(validQuestions);
    // const result = await pendingQuestionService.createPendingQuestionsBulk(validQuestions);

    return result;
  } catch (error) {
    console.error("Error in generateQuestions:", error.message);
    throw error;
  }
};

const callOpenAPI = async (prompt) => {
  try {
    // const response = await axios.post(
    //   "https://api.openai.com/v1/completions",
    //   {
    //     model: "gpt-4",
    //     prompt,
    //     max_tokens: 1000,
    //     temperature: 0.7,
    //   },
    //   {
    //     headers: {
    //       Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
    //       "Content-Type": "application/json",
    //     },
    //   }
    // );

    // TO Test
    const response = {
        data: {
            choices: [
            {
                text: `[

                {
                    "question_text": "What is the capital of France?",
                    "answer_format": "multiple_choice",
                    "correct_answer": "Paris",
                    "explanation": "Paris is the capital of France",
                    "distractors": ["London", "Berlin", "Madrid"]
                },
                {
                    "question_text": "What is 2 + 2?",
                    "answer_format": "multiple_choice",
                    "correct_answer": "4",
                    "explanation": "2 + 2 = 4",
                    "distractors": ["3", "5", "6"]
                }
            ]`
            }
        ]
    }}; // Simulate OpenAI response

    const llmResponse = response.data.choices[0].text.trim();
    return llmResponse;
    } catch (error) {
    console.error("Error in callOpenAPI:", error.message);
    throw new Error("Failed to call OpenAI API");
    }  
};

const getTopicById = async (topic_id) => {
    const [topic_name] = await db.execute("SELECT topic_name FROM Topics WHERE topic_id = ?", [topic_id]);
    
    if (topic_name.length === 0 || !topic_name) {
        throw new Error("Invalid topic_id");
    }

    topic = topic_name[0].topic_name;
    topic = topic.replaceAll(" ", "_");
    return topic;
}

const getDifficultyById = async (difficulty_id) => {
    const [difficulty_label] = await db.execute("SELECT label FROM Difficulty_Levels WHERE difficulty_id = ?", [difficulty_id]);
    
    if (difficulty_label.length === 0 || !difficulty_label) {
        throw new Error("Invalid difficulty_id");
    }

    difficulty = difficulty_label[0].label;
    return difficulty;
}

const getPromptByTopicAndDifficulty = (topic, difficulty) => {
    const templateFileName = `${difficulty}_${topic}.jinja2`;
    const templateFilePath = path.join(__dirname, "../../llm", templateFileName);

    if (!fs.existsSync(templateFilePath)) {
      throw new Error(`Template file ${templateFileName} not found`);
    }

    // Read the Jinja2 template file
    const prompt = fs.readFileSync(templateFilePath, "utf-8");

    return prompt;
}

module.exports = {
    generateQuestions,
  };

